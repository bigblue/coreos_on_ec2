#!/bin/bash
#
# Launch instances to create new coreos cluster
# Version 0.0.1
#
# Run ./launchInstances.sh -h for usage information
#
#include helpers
source "./_common.sh"

### Script logic
#####################################################################

version="v0.0.1"

# Print usage
usage() {
  echo -n "$(basename $0) [OPTION]... 

Launch instances to create new coreos cluster

Options:
 -n, --number    Number of instances to launch [default: 1]
 -g, --group     Security group name for new instances [default: coreosgroup]
 -r, --region    Region to launch instance(s) in, comma seperate multiple regions 
                 e.g. 'us-east-1, us-west-1' [default: us-west-1]
 -k, --key       Path to public key of keypair to use 
                 [default: ~/.ssh/CoreOSKey_rsa.pub]
                 A new keypair will be generated if file does not exist
 -t, --token     Discovery token to use (will be inserted into userdata)
                 [default: New token will be autogenerated from 
                  https://discovery.etcd.io/new ]
 -u, --userdata  Path to userdata file to boot instances with
                 [default: ./single_region_userdata.yml]
 -s, --skip-aws-checks Skip checking if aws cli is installed
 -h, --help      Display this help and exit
     --version   Output version information and exit
"
}

ami_ids=("ami-57950a20" "ami-0c300d11" "ami-343b195c" "ami-83d533c7" 
          "ami-0989a439" "ami-b128dcb1" "ami-fa0b3aa8" "ami-bbb5c581" 
          "ami-2154ec3c")

# Set a trap for cleaning up in case of errors or when script exits.
rollback() {
  die
}

main() {
  regions=($(echo "$regions" | tr -d '[[:space:]]' | tr "," "\n" ))
  regionLength=${#regions[@]}

  if [ -z $token ]; then
    if [ $regionLength -gt 1 ]; then
      token=$(curl --silent "https://discovery.etcd.io/new?size=${regionLength}")
    else
      token=$(curl --silent "https://discovery.etcd.io/new?size=${instances}")
    fi
  fi

  if [ ! -f "$userdata_path" ]; then
    die "The userdata file does not exist, and is required to launch an instance"
  else
    escaped_token=$(escape $token)
    userdata=$(cat $userdata_path | sed -e "s/\${token}/$escaped_token/")
  fi

  eval key_path=$key_path
  private_key=$(echo $key_path | sed "s/\.pub$//")
  key_name=$(basename $private_key)
  if [ ! -f "$key_path" ]; then
    out "Generating a new key pair - you will be prompted to enter a new password.
Leave blank to generate key with no password."
    ssh-keygen -q -t rsa -C "Core OS cluster key" -f "$private_key"
  fi

  if [ $regionLength -gt 1 ]; then
    printf "%s\n" "${regions[@]}" | xargs -n 1 -P "$regionLength" ./$0 -s "true" -n 1 -g "$securitygroup" -k "$key_path" -t "$token" -u "$userdata_path" -r
  else
      coreosgroup=$(aws --region "$regions" ec2 describe-security-groups --output=text | grep "$securitygroup" | cut -s -f 3)
      if [ -z "$coreosgroup" ]; then
        coreosgroup=$(aws --region "$regions" ec2 create-security-group --group-name "$securitygroup" --description "CoreOS instances" --output text)
        ports=(22 4001 7001)
        for port in "${ports[@]}"; do aws --region "$regions" ec2 authorize-security-group-ingress --group-id "$coreosgroup" --protocol tcp --port "$port" --cidr 0.0.0.0/0; done
      fi

      public_key=$(cat $key_path)
      keypair=$(aws --region "$regions" ec2 describe-key-pairs --output "text" | grep "$key_name")
      if [ -z "$keypair" ]; then
        echo -n "Adding key to ec2: "
        aws --region "$regions" ec2 import-key-pair --key-name "$key_name" --public-key-material "$public_key" --output="text"
      fi

      regionIndex=$(regionIndex $regions)
      ami_id=${ami_ids[$regionIndex]}

      aws --region "$regions" ec2 run-instances --image-id "$ami_id" --count "$instances" --instance-type "m1.small" --security-group-ids "$coreosgroup" --key-name "$key_name" --monitoring "Enabled=true" --user-data "$userdata"

  fi
}

### Boilerplate
#####################################################################

# Iterate over options breaking -ab into -a -b when needed and --foo=bar into
# --foo bar
optstring=h
unset options
while (($#)); do
  case $1 in
    # If option is of type -ab
    -[!-]?*)
      # Loop over each character starting with the second
      for ((i=1; i < ${#1}; i++)); do
        c=${1:i:1}

        # Add current char to options
        options+=("-$c")

        # If option takes a required argument, and it's not the last char make
        # the rest of the string its argument
        if [[ $optstring = *"$c:"* && ${1:i+1} ]]; then
          options+=("${1:i+1}")
          break
        fi
      done
      ;;
    # If option is of type --foo=bar
    --?*=*) options+=("${1%%=*}" "${1#*=}") ;;
    # add --endopts for --
    --) options+=(--endopts) ;;
    # Otherwise, nothing special
    *) options+=("$1") ;;
  esac
  shift
done
set -- "${options[@]}"
unset options

# Set our rollback function for unexpected exits.
trap rollback INT TERM EXIT

### Main loop
#####################################################################

# Read the options and set stuff
instances=1
securitygroup="coreosgroup"
regions="us-west-1"
key_path="~/.ssh/CoreOSKey_rsa.pub"
token=""
userdata_path="./single_region_userdata.yml"
skip_aws_checks=false

while [[ $1 = -?* ]]; do
  case $1 in
    -h|--help) usage >&2; safe_exit ;;
    --version) out "$(basename $0) $version"; safe_exit ;;
    -n|--number) shift; instances=$1 ;;
    -g|--group) shift; securitygroup=$1 ;;
    -r|--region) shift; regions=$1 ;;
    -k|--key) shift; key_path=$1 ;;
    -t|--token) shift; token=$1 ;;
    -u|--userdata) shift; userdata_path=$1 ;;
    -s|--skip-aws-checks) shift; skip_aws_checks=true ;;
    --endopts) shift; break ;;
  esac
  shift
done

# Store the remaining part as arguments.
args+=("$@")

### Run it
#####################################################################

if ! [ $skip_aws_checks == true ]; then
  check_aws_cli
fi

main

safe_exit
